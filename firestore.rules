rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- HELPER FUNCTIONS ---
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // --- TYPE CHECKS ---
    function isString(data, field) {
      return data.keys().hasAny([field]) && data[field] is string;
    }

    function isNumber(data, field) {
      return data.keys().hasAny([field]) && (data[field] is int || data[field] is float);
    }

    // --- SCHEMA VALIDATORS ---
    // --- SCHEMA VALIDATORS ---
    function isValidPatient(data) {
      return data.keys().hasAll(['name', 'age', 'diagnosis'])
          && data.name is string
          && (data.age is int || data.age is float)
          && data.diagnosis is string;
    }

    function isValidSession(data) {
      return isString(data, 'date') &&
             isString(data, 'time') && 
             isString(data, 'type'); // strict: must have type
    }

    // --- USERS (Recursive: Owns everything under their doc) ---
    match /users/{userId}/{document=**} {
      allow read, write: if isOwner(userId);
    }

    // --- PATIENTS ---
    // --- PATIENTS ---
    match /patients/{patientId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      allow create: if isAuthenticated() 
                   && request.resource.data.userId == request.auth.uid;
                   // && isValidPatient(request.resource.data);
      
      allow update: if isAuthenticated() 
                   && resource.data.userId == request.auth.uid
                   && request.resource.data.userId == request.auth.uid; // Prevent ownership transfer
                   // && isValidPatient(request.resource.data);

      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Subcollections (Sessions within Patient)
      match /sessions/{sessionId} {
         // Helper to check parent ownership
         function isParentOwner() {
            return get(/databases/$(database)/documents/patients/$(patientId)).data.userId == request.auth.uid;
         }

         allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
         
         allow create: if isAuthenticated() 
                      && request.resource.data.userId == request.auth.uid
                      && isParentOwner(); // TITANIUM SECURITY: Must own parent
                      // && isValidSession(request.resource.data);
         
         allow update: if isAuthenticated()
                      && resource.data.userId == request.auth.uid
                      && isParentOwner();
                      // && isValidSession(request.resource.data);
         
         allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
      }

      // Subcollection: Clinical Documents (Files)
      // FIX 403: This was missing, blocking the metadata sync after upload.
      match /documents/{documentId} {
         allow read: if isAuthenticated(); // Team Access: All staff can view documents
         allow create: if isAuthenticated() && request.resource.data.uploadedBy == request.auth.uid;
         allow update: if isAuthenticated() && resource.data.uploadedBy == request.auth.uid;
         allow delete: if isAuthenticated(); // TITANIUM FIX: Allow team delete (Admin/Staff)
      }
    }

    // --- COLLECTION GROUP: SESSIONS (Recursive Wildcard) ---
    // This is required for db.collectionGroup('sessions') queries to work regardless of path
    match /{path=**}/sessions/{sessionId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    match /activity_logs/{logId} {
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow list: if isAuthenticated() && request.query.limit <= 500 && resource.data.userId == request.auth.uid;
      allow update, delete: if false; 
    }

    // --- DAILY NOTES (Clinical Blackboard) ---
    match /daily_notes/{noteId} {
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // --- FINANCIAL SECURITY (MAGELLAN PHASE 1.2) ---
    match /invoices/{invoiceId} {
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // IMMUTABILITY: Cannot edit if already PAID (Financial Integrity)
      allow update: if isAuthenticated() 
                   && resource.data.userId == request.auth.uid
                   && resource.data.status != 'PAID'; 
                   
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Shared Sequence Counter for Atomic IDs
    match /sequences/invoices {
       allow read, write: if isAuthenticated();
    }
  }
}
